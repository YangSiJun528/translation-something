원본: [The Grug Brained Developer - A layman's guide to thinking like the self-aware smol brained](https://grugbrain.dev/)

claude 3.5 sonnet을 사용한 번역. 

grug의 정확한 의미를 모르겠지만, 대충 느낌 상 원시인이라고 번역했는데, 이상할수도 있음. (방망이, 반짝이는 돌맹이... 등 단어를 보고)

----
# 평범한 사람을 위한 자의식 있는 작은 뇌 처럼 생각하는 방법 안내서

# 서문
이 글은 원시인 개발자가 모은 소프트웨어 개발에 대한 생각들입니다.

원시인 개발자는 그리 똑똑하지 않지만, 오랜 세월 프로그래밍을 하면서 여전히 대부분 혼란스럽긴 하지만 몇 가지를 배웠습니다.

원시인 개발자는 자신의 배움을 작고 이해하기 쉬우면서도 재미있는 페이지로 모아보려 합니다. 이는 젊은 원시인인 여러분을 위해서일 뿐만 아니라, 나이가 들수록 아침에 무엇을 먹었는지, 바지를 입었는지 같은 중요한 것들을 잊어버리는 자신을 위해서이기도 합니다.

"큰 뇌"를 가진 개발자들은 많고, 어떤 이들은 이것을 좋아하지 않을 수 있으며 얼굴을 찌푸릴 것입니다.

자신이 "큰 뇌"를 가진 개발자라고 *생각하는* 사람들은 훨씬 더 많으며, 더 많은 이들이 분명 아마도 이것을 좋아하지 않을 것이고, 많은 이들이 얼굴을 찌푸릴 것입니다 (인터넷이란 게 그렇죠).

(참고: 원시인도 한때는 "큰 뇌"라고 생각했지만 힘든 방법으로 깨달았습니다)

괜찮습니다!

당신 마음대로 해도 되고, 결국 그렇게 중요한 건 아니지만, 원시인은 여러분이 읽는 것을 즐기고 원시인이 긴 프로그래밍 인생 동안 저지른 수많은 실수로부터 뭔가를 배우기를 바랍니다.

# 영원한 적: 복잡성

원시인의 최상위 포식자는 복잡성입니다.

복잡성은 나쁩니다.

다시 말하면:

복잡성은 *매우* 나쁩니다.

*여러분도* 따라 해보세요:

복잡성은 *매우*, *매우* 나쁩니다.

복잡성과 티라노사우루스 중 하나를 선택해야 한다면, 원시인은 티라노사우루스를 선택할 것입니다: 최소한 티라노사우루스는 볼 수 있으니까요.

복잡성은 선의를 가졌지만 결국엔 몽둥이로 때리고 싶어지는, 원시인의 뇌를 가지지 않은 개발자들과 복잡성이라는 악령을 두려워하지 않거나 때로는 그 존재조차 모르는 프로젝트 매니저들을 통해 코드베이스에 침투하는 악령입니다.

어느 날까지만 해도 코드베이스가 이해 가능했고 원시인이 일을 할 수 있었으며, 모든 게 좋았습니다!

그 다음날은 불가능해졌습니다: 복잡성 악령이 코드에 침투했고 매우 위험한 상황이 되었습니다!

원시인은 복잡성 악령을 볼 순 없지만, 코드베이스에서 그 존재를 감지할 수 있습니다.

복잡성 악령이 이곳의 변경사항이 저곳의 관련 없는 것을 망가뜨리는 것을 보며 조롱합니다. 뭐라고요!?! 조롱 조롱 조롱 하하 정말 재미있군요 원시인은 프로그래밍을 사랑하고 원시인의 선배가 조언한 것처럼 반짝이는 돌 투기꾼이 되지 않을 겁니다.

몽둥이는 악령 복잡성에게 통하지 않고 실제로 악령을 들여보낸 개발자를 몽둥이로 때리는 것도 좋은 생각이 아닙니다: 때로는 그게 원시인 자신이니까요!

슬프게도, 자주 원시인 자신입니다.

그래서 원시인은 다시 말하고 자주 말합니다: 복잡성은 *매우*, *매우* 나쁩니다.

# "아니오"라고 말하기

복잡성 악령에 대항하는 최고의 무기는 마법의 단어입니다: "아니오"

"아니오, 원시인은 그 기능을 만들지 않을 것입니다"

"아니오, 원시인은 그 추상화를 만들지 않을 것입니다"

"아니오, 원시인은 매일 몸에 물을 뿌리지 않을 것이고 검은 생각 주스(커피)를 줄이지도 않을 것입니다. 이제 그만 물어보세요"

참고로, 이것은 좋은 엔지니어링 조언이지만 나쁜 경력 조언입니다: "네"는 더 많은 반짝이는 돌(돈)을 얻고 큰 개발자 부족의 책임자가 되기 위한 마법의 단어입니다.

슬프지만 사실입니다: "네"를 배우고 실패했을 때 다른 원시인들을 탓하는 법을 배우는 것이 이상적인 경력 조언입니다.

하지만 원시인은 원시인답게 진실되어야 하고, "아니오"는 원시인의 마법의 단어입니다. 처음에는 말하기 어렵습니다, 특히 당신이 착한 원시인이고 사람들을 실망시키고 싶지 않다면 말이죠 (많은 원시인들이 그렇습니다!) 하지만 시간이 지나면서 쉬워집니다. 비록 반짝이는 돌 더미가 그렇지 않았을 때보다 높지 않더라도 말이죠.

괜찮습니다: 원시인에게 정말 얼마나 많은 반짝이는 돌이 필요할까요?

# "좋아요"라고 말하기

때로는 타협이 필요합니다. 그렇지 않으면 반짝이는 돌이 없고, 공룡 고기도 없게 되죠. 좋지 않습니다. 아내는 집에 있는 어린 원시인들이 지붕과 음식 등이 필요하다는 것을 단호하게 상기시켜주며, 원시인의 50번째 복잡성 악령 잔소리에는 관심이 없습니다.
이런 상황에서 원시인은 "좋아요"를 추천합니다.

"좋아요, 원시인이 그 기능을 만들겠습니다"

그런 다음 원시인은 시간을 들여 문제에 대한 80/20 해결책을 생각하고 그것을 대신 만듭니다. 80/20 해결책은 "20%의 코드로 80%의 원하는 것"을 얻는다는 의미입니다. 프로젝트 매니저가 원하는 모든 부가 기능을 가지고 있지 않을 수 있고, 약간 못생겼을 수 있지만, 작동하고 대부분의 가치를 전달하며, 대부분의 경우 복잡성 악령을 막아냅니다.

때로는 프로젝트 매니저에게 말하지 않고 80/20 방식으로 하는 것이 최선일 수 있습니다. 용서를 구하는 것이 허가를 구하는 것보다 쉽습니다. 프로젝트 매니저들의 마음은 때때로 나비처럼 바쁘고 많은 원시인들을 다루느라 과로합니다. 종종 기능이 무엇을 해야 하는지조차 잊어버리거나, 다른 일로 넘어가거나, 사직하거나, 해고됩니다. 원시인은 많은 그런 사례를 보았습니다.

어쨌든 이것은 프로젝트 매니저들에게도 최선의 이익이므로 원시인은 보통 이런 접근 방식에 대해 너무 나쁘게 느끼지 않습니다.


# 코드 분할하기

다음 전략은 훨씬 더 어렵습니다: 코드베이스를 적절히 나누는 것입니다 (멋진 말로: "코드를 적절히 분할하기"). 여기서는 각 시스템이 너무나 다르기 때문에 일반적인 조언을 하기가 어렵습니다. 하지만, 원시인이 믿게 된 한 가지가 있습니다: 너무 일찍 애플리케이션을 분할하지 마세요!

프로젝트 초기에는 모든 것이 매우 추상적이고 물과 같습니다: 원시인의 고군분투하는 뇌가 붙잡을 수 있는 단단한 것이 거의 없죠. 시스템의 "모양"을 발전시키고 무엇을 하고 있는지 배우는 데 시간이 걸립니다. 원시인은 프로젝트 초기에는 분할을 시도하지 않다가, 어느 시점에서 코드베이스에서 좋은 분할점이 나타나길 기다립니다.

좋은 분할점은 시스템의 나머지 부분과 좁은 인터페이스를 가집니다: 복잡성 악령을 마치 수정 안에 갇힌 것처럼 내부적으로 숨기는 적은 수의 함수나 추상화입니다.

원시인은 복잡성 악령이 적절히 수정에 갇혔을 때 매우 만족스럽습니다. 숙적을 가두는 것은 최고의 기분이죠!

원시인은 코드에서 분할점이 나타나는 것을 인내심을 가지고 지켜보며, 경험과 함께 시간이 지나면서 천천히 리팩터링하며 코드베이스가 형태를 갖추게 합니다. 이에 대한 엄격한 규칙은 없습니다: 원시인은 분할점을 볼 때 그것이 분할점임을 알 수 있습니다. 그저 보는 기술을 키우는 데 시간과 인내심이 필요할 뿐입니다.

때로는 원시인이 너무 일찍 시도해서 추상화를 잘못 만들기도 하므로, 원시인은 기다리는 쪽으로 편향됩니다.

"큰 뇌"를 가진 개발자들은 종종 이것을 전혀 좋아하지 않고 프로젝트 시작부터 많은 추상화를 발명합니다.

원시인은 몽둥이를 들고 "「큰 뇌」는 코드를 유지보수하지 않아! 「큰 뇌」는 다음 아키텍처 위원회로 가버리고 코드는 원시인이 처리하도록 남겨둬!"라고 외치고 싶은 유혹을 받습니다.

하지만 원시인은 열정을 제어하는 법을 배웠습니다. 이것이 원시인과 동물의 주요 차이점입니다.

대신 원시인은 UML 다이어그램 같은 것을 주거나 (코드에 해를 끼치지 않고, 어차피 아마 버려질 것입니다) 내일 작동하는 데모를 요구함으로써 프로젝트 초기에 "큰 뇌" 개발자의 피해를 제한하려고 합니다.

작동하는 데모는 특히 좋은 트릭입니다: "큰 뇌"가 이야기할 수 있는 것을 실제로 작동하게 만들고 일을 하는 코드를 보게 만듭니다. 이는 "큰 뇌"가 현실을 더 빨리 보는 데 도움이 될 것입니다.

기억하세요! "큰 뇌"는 큰 뇌를 가지고 있습니다! 단지 좋은 방향으로 길들여져야 하고 실수로 복잡성 악령을 위해 봉사하지 않도록 해야 합니다. 많이 봤죠.
(가장 뛰어난 원시인의 뇌는 여러 "큰 뇌"를 올바른 방향으로 이끌어 많은 복잡성 악령 함정 수정을 만들 수 있습니다. 그런 원시인을 기다리는 것은 큰 반짝이는 돌 더미입니다!)

또한 데모 접근 방식을 "프로토타입"이라고 부르기도 합니다. 프로젝트 매니저에게 더 멋지게 들리죠.

원시인은 소프트웨어를 만들 때 초기에 프로토타입을 만들라고 말합니다. *특히* "큰 뇌"들이 많다면 말이죠.

# 테스팅

원시인은 테스트와 애증 관계를 가지고 있습니다: 테스트는 원시인을 셀 수 없이 많이 구해주었고 원시인은 테스트를 사랑하고 존중합니다.

불행히도 많은 테스트 주술사들이 존재합니다. 어떤 테스트 주술사들은 테스트를 우상으로 만들어, 원시인이 코드를 쓰기도 전에, 심지어 도메인을 이해하기도 전에 "테스트 우선"같은 것들을 요구합니다!

원시인이 아직 도메인도 이해하지 못했는데 어떻게 테스트를 하나요!?

"아, 걱정하지 마세요: 테스트가 당신이 해야 할 일을 보여줄 거예요."

원시인은 다시 한번 천천히 몽둥이를 잡으려는 자신을 발견하지만, 침착함을 유지합니다.

원시인은 대신 프로토타입 단계 이후, 코드가 안정화되기 시작했을 때 대부분의 테스트를 작성하는 것을 선호합니다.

하지만 잘 기억하세요: 여기서 원시인은 매우 엄격해야 합니다!

"원시인의 기계에서는 작동하니까" 라며 테스트를 작성하지 않고 넘어가기 쉽습니다!

이것은 매우, 매우 나쁩니다: 다른 기계에서 작동한다는 보장도 없고 미래에 원시인의 기계에서 작동한다는 보장도 없으며, 이런 일이 많이 있었습니다.

테스트 주술사들은 테스트의 중요성에 대해 좋은 지적을 합니다. 비록 테스트 주술사들이 종종 인생에서 유용한 기능을 완성한 적이 없고 항상 테스트에 대해서만 이야기하며, 몽둥이로 때릴 만하지만 마음은 올바른 곳에 있습니다.
또한, 테스트 주술사들은 종종 단위 테스트에 대해 많이 이야기하지만, 원시인은 그렇게 유용하다고 생각하지 않습니다. 원시인의 경험상 이상적인 테스트는 단위 테스트도 종단 간 테스트도 아닌, 그 중간에 있습니다.

단위 테스트는 괜찮습니다, 좋아요, 하지만 구현이 변경됨에 따라 깨지고 (API와 비교하면 많이!) 리팩터링을 어렵게 만들며, 솔직히 많은 버그들은 여전히 다른 코드와의 상호작용 때문에 발생합니다. 코드가 변경될 때 종종 버려집니다.

원시인은 프로젝트 시작할 때 주로 단위 테스트를 작성합니다. 일을 진행하는 데 도움이 되지만 너무 애착을 가지거나 장기적인 가치를 기대하지는 않습니다.

종단 간 테스트는 좋습니다. 전체 시스템이 작동하는 것을 보여주지만! 깨졌을 때 이해하기 어렵고 원시인을 매우 자주 미치게 만듭니다. 때로는 원시인들이 "아, 그거 항상 깨지잖아"라며 무시하게 되는데, 이는 매우 나쁩니다!

중간 테스트는, 원시인이 들은 바로는 주술사들이 때때로 "통합 테스트"라고 부르며 종종 얼굴을 찌푸리며 말합니다. 하지만 원시인이 말하길 통합 테스트가 최적의 지점입니다: 시스템의 정확성을 테스트하기에 충분히 높은 수준이면서, 좋은 디버거와 함께라면 무엇이 깨졌는지 보기 쉬울 만큼 충분히 낮은 수준입니다.

원시인은 특히 시작할 때 몇몇 단위 테스트를 선호하지만 모든 코드를 100% 테스트하지는 않으며 절대로 "테스트 우선"은 하지 않습니다. "가면서 테스트하기"가 원시인에게는 꽤 잘 작동합니다. 특히 원시인이 일을 파악해 나갈 때 말이죠.

원시인은 분할점이 나타나고 시스템이 안정화되면서 맹렬한 통합 테스트 노력에 집중합니다! 분할점 API는 구현에 비해 희망적으로 안정적이고 통합 테스트는 오랫동안 가치 있게 남아있으며, 디버깅하기 쉽습니다.

또한 작고 잘 관리된 종단 간 테스트 스위트가 만들어져서 몽둥이로 때릴 것처럼 종교적으로 작동하도록 유지됩니다. 중요한 종단 간 테스트는 가장 일반적인 UI 기능들과 몇 가지 매우 중요한 엣지 케이스에 집중하지만, 너무 많지는 않습니다. 그러면 유지보수가 불가능해지고 무시되기 때문입니다.

이것이 원시인에게는 이상적인 테스트 세트입니다.

여러분이 좋아하지 않을 수도 있지만, 이것이 원시인 테스팅의 정점입니다.

또한, 원시인은 테스트에서 모킹을 싫어합니다. 절대적으로 필요할 때만 (드물게/거의 없음) 선호하며, 그때도 큰 단위의 모킹(분할점/시스템)만 합니다.

원시인이 싫어하는 "테스트 우선"의 한 가지 예외가 있습니다: 버그가 발견되었을 때입니다. 원시인은 항상 먼저 회귀 테스트로 버그를 재현한 *다음* 버그를 수정하려고 합니다. 이 경우에만 어떤 이유에서인지 더 잘 작동합니다.

# 애자일

원시인은 애자일이 끔찍하지도, 좋지도 않다고 생각합니다.

결국, 개발을 조직하는 최악의 방법은 아니고, 아마도 다른 것들보다 나을 수도 있다고 원시인은 생각하며 괜찮습니다.

하지만 위험한 것은 애자일 주술사입니다! 애자일 주술사에게 많은, 정말 많은 반짝이는 돌을 잃었습니다!

애자일 프로젝트가 실패할 때마다, 애자일 주술사는 "당신이 애자일을 제대로 하지 않았어요!"라고 말합니다. 원시인은 이것이 애자일 주술사에게 매우 편리하다고 지적하며,  젊은 원시인들에게 더 나은 애자일 교육을 위해 더 많은 반짝이는 돌을 요구합니다. 위험합니다!

원시인은 애자일 이야기가 너무 많이 나올 때 몽둥이를 들고 싶은 유혹을 받지만 항상 침착함을 유지합니다.

프로토타이핑, 도구들, 그리고 좋은 원시인들을 고용하는 것이 소프트웨어 성공의 더 나은 핵심입니다: 애자일 프로세스는 괜찮고 어느 정도 도움이 되지만 때로는 너무 심각하게 받아들이면 해가 됩니다.

원시인은 애자일 주술사가 뭐라고 하든(위험!) 모든 소프트웨어 문제를 해결하는 은 몽둥이는 없다고 말합니다.

# 리팩터링

리팩터링은 좋은 활동이고 종종 좋은 생각입니다. 특히 프로젝트 후반에 코드가 안정화되었을 때 말이죠.

하지만 원시인은 경력 동안 많은 "리팩터링"이 끔찍하게 잘못되어 도움보다 해를 더 많이 끼치는 것을 보았습니다.

원시인은 왜 어떤 리팩터링은 잘 작동하고 어떤 것은 실패하는지 정확히 알지 못하지만, 리팩터링이 클수록 실패할 가능성이 더 높아 보인다는 것을 알아챘습니다.

그래서 원시인은 리팩터링을 비교적 작게 유지하고 리팩터링 중에 "해안가에서 너무 멀리 나가지" 않으려고 합니다. 이상적으로는 시스템이 전체 시간 동안 작동하고 각 단계가 다른 것이 시작되기 전에 완료되어야 합니다.

종단 간 테스트는 여기서 생명의 은인이지만, 종종 왜 깨졌는지 이해하기가 매우 어렵습니다... 이것이 리팩터링의 삶입니다.

또한 원시인은 너무 많은 추상화를 도입하는 것이 종종 리팩터링 실패와 시스템 실패로 이어진다는 것을 알아챘습니다. 좋은 예시는 J2EE 도입이었는데, 많은 "큰 뇌"들이 앉아서 너무 많은 추상화를 생각했고, 좋은 것은 아무것도 나오지 않았으며 많은 프로젝트가 피해를 입었습니다.

또 다른 좋은 예시는 원시인이 일하던 회사가 코드베이스에서 복잡성 악령을 관리/가두기 위해 OSGi를 도입했을 때입니다. OSGi는 도움이 되지 않았을 뿐만 아니라, 복잡성 악령을 훨씬 더 강력하게 만들었습니다! 재작업하는 데 최고의 개발자들의 여러 인년이 걸렸을 뿐만 아니라 부트하는 데도 걸렸습니다! 더 복잡한 악령과 함께 이제 기능 구현이 불가능해졌습니다! 매우 나쁩니다!

# 체스터튼의 울타리

현명한 원시인 주술사 체스터튼이 한때 말했습니다.

> 어떤 제도나 법이 존재하는 경우가 있습니다. 단순화를 위해, 길을 가로지르는 울타리나 문이라고 합시다. 더 현대적인 유형의 개혁가는 즐겁게 그것으로 다가가서 말합니다, "나는 이것의 용도를 모르겠어. 치워버리자." 이에 대해 더 지적인 유형의 개혁가는 이렇게 대답하는 것이 좋을 것입니다: "당신이 그것의 용도를 모른다면, 나는 확실히 당신이 그것을 치우도록 두지 않을 것입니다. 가서 생각해 보세요. 그리고 당신이 그것의 용도를 이해했다고 말할 수 있을 때 돌아오면, 나는 당신이 그것을 파괴하도록 허락할 수 있을 것입니다."

많은 나이 든 원시인은 이 교훈을 잘 배워서 아무리 못생겼어 보여도 함부로 코드를 제거하지 않습니다.

원시인은 모든 프로그래머가 어느 정도 플라톤주의자여서 코드에서 천상의 음악 같은 완벽함을 바란다는 것을 이해합니다. 하지만 여기에 위험이 있습니다. 세상은 종종 못생기고 엉망이어서 코드도 그래야만 합니다.

겸손함은 "큰 뇌"나 자신을 "큰 뇌"라고 생각하는 사람들, 심지어 원시인에게도 쉽게 오지 않지만, 원시인은 종종 "오, 원시인은 이것의 모습이 마음에 들지 않아, 원시인이 고칠 거야"가 원시인에게 많은 시간의 고통을 가져오고 더 나아지지 않거나 시스템이 더 나빠지는 것을 발견했습니다.

경력 초기에 원시인은 종종 몽둥이를 미친 듯이 휘두르며 코드베이스에 달려들어 모든 것을 부수곤 했는데, 이것이 좋지 않다는 것을 배웠습니다.

원시인이 시스템을 절대 개선하지 말라고 하는 것은 아닙니다. 그것은 매우 어리석은 일이겠죠. 하지만 특히 시스템이 클수록 먼저 시스템을 이해하는 데 시간을 들이고 완벽하지 않더라도 오늘 작동하는 코드를 존중하라고 권장합니다.

여기서 테스트는 종종 울타리를 부수지 말아야 할 이유에 대한 좋은 힌트가 됩니다!

# 마이크로서비스

원시인은 "큰 뇌"가 왜 시스템을 올바르게 분할하는 가장 어려운 문제를 가져와서 거기에 네트워크 호출까지 추가하는지 궁금합니다.
원시인에게는 매우 혼란스럽게 보입니다.

# 도구

원시인은 도구를 사랑합니다. 도구와 열정을 통제하는 것이 원시인을 공룡과 구분 짓는 것입니다! 도구는 원시인 대신 생각을 해줌으로써 그렇지 않으면 불가능한 코드를 만들 수 있게 해줍니다. 항상 좋은 안도감입니다! 원시인은 항상 새로운 곳에서 생산성을 최대화하기 위해 주변의 도구들을 배우는 데 시간을 보냅니다: 2주 동안 도구를 배우면 개발이 종종 두 배 더 빨라지며, 종종 문서가 없어서 다른 개발자들에게 도움을 요청하며 찾아다녀야 합니다.

IDE의 코드 완성 기능은 원시인이 모든 API를 기억하지 않아도 되게 해줍니다. 매우 중요한 기능입니다! 원시인에게 자바 프로그래밍은 이것 없이는 거의 불가능합니다!

때때로 원시인이 이런(IDE 없는 끔찍한 개발) 생각을 하게 될 정도로.

좋은 디버거는 반짝이는 돌의 무게만큼의 가치가 있습니다. 사실은 그 이상입니다: 버그에 직면했을 때 원시인은 종종 모든 반짝이는 돌과 아마도 몇몇 자식들까지도 좋은 디버거와 교환할 것입니다. 어쨌든 원시인이 아는 한 디버거는 아무런 무게도 나가지 않습니다.

원시인은 항상 새로운 프로그래머에게 조건부 중단점, 식 평가, 스택 탐색 등과 같은 기능들을 포함해 사용 가능한 디버거를 매우 깊이 있게 배우라고 권장합니다. 새로운 원시인에게 종종 대학 수업보다 컴퓨터에 대해 더 많이 가르쳐 줍니다!

원시인은 절대로 도구 개선을 멈추지 말라고 말합니다.

# 타입 시스템
원시인은 프로그래밍을 더 쉽게 만드는 타입 시스템을 매우 좋아합니다. 원시인에게는 키보드에서 점을 치면 원시인이 할 수 있는 것들의 목록이 마법처럼 나타날 때 타입 시스템이 가장 가치 있습니다. 이것이 원시인에게는 타입 시스템 가치의 90% 이상입니다.

"큰 뇌" 타입 시스템 주술사들은 종종 타입 정확성이 타입 시스템의 주요 목적이라고 말하지만, 원시인은 일부 "큰 뇌" 타입 시스템 주술사들 중 많은 사람들이 실제로 제품/서비스로 코드를 배포하지 않는다는 것을 알아챘습니다. 배포되지 않은 코드는 어떤 면에서는 '정확'하다고 할 수 있겠지만, 이건 원시인이 말하는 진정한 의미의 '정확함'이 아닙니다.

원시인은 할 수 있는 것이 마법처럼 나타나고 코드를 완성해주는 도구가 타입 시스템의 가장 큰 이점이라고 말합니다. 정확성도 좋지만 그만큼 중요하지는 않습니다.

또한, 종종 여기서 "큰 뇌"들을 주의하세요!
어떤 타입의 "큰 뇌"는 타입 시스템을 보조 정리(lemma)로 생각하고 말하는 전문가들이 있는데, 이건 잠재적 위험입니다!
추상화가 너무 높으면, "큰 뇌" 타입 시스템 코드는 플라톤적 일반 튜링 계산 모델의 천체 투영이 코드베이스에 되어버립니다. 원시인은 혼란스럽고 어느 정도 매우 우아하다는 것에 동의하지만, Grug Inc.의 몽둥이 재고 수를 기록하는 것과 같은 실무적인 과제를 하기가 매우 어렵습니다.

제네릭은 여기서 특히 위험합니다. 원시인은 대부분 가장 가치가 있는 컨테이너 클래스에 제네릭을 제한하려고 노력합니다.
제네릭의 유혹은 매우 큰 속임수입니다! 복잡성 악령이 이 한 가지 속임수를 좋아합니다! 조심하세요!

항상 타입 시스템의 가장 큰 가치는: 점을 치면 원시인이 할 수 있는 것을 보는 것입니다. 절대 잊지 마세요!

# 표현식 복잡성
원시인은 한때 가능한 한 코드 줄을 최소화하는 것을 좋아했습니다. 이렇게 코드를 작성했죠:

```js
  if(contact && !contact.isActive() && (contact.inGroup(FAMILY) || contact.inGroup(FRIENDS))) {
    // ...
  }
```

시간이 지나면서 원시인은 이것이 디버깅하기 어렵다는 것을 배웠고, 이렇게 쓰는 것을 선호하게 되었습니다:

```js
  if(contact) {
    var contactIsInactive = !contact.isActive();
    var contactIsFamilyOrFriends = contact.inGroup(FAMILY) || contact.inGroup(FRIENDS);
    if(contactIsInactive && contactIsFamilyOrFriends) {
        // ...
    }
  }
```

원시인은 많은 코드 줄과 쓸모없는 변수에 대한 공포에 젊은 원시인들이 비명을 지르는 것을 듣고 몽둥이로 자신을 방어할 준비를 합니다.

다른 개발자들이 공격하면서 몽둥이 싸움이 시작되고 원시인은 소리칩니다: "디버깅이 더 쉽다! 각 표현식의 결과를 더 명확하게 보고 좋은 이름을 짓는다! 조건식을 이해하기가 더 쉽다! 디버깅이 더 쉽다!"

확실히 디버깅이 더 쉽고 몽둥이 싸움이 끝나고 진정되어 젊은 원시인이 조금 생각해보면, 그들은 원시인이 옳다는 것을 깨닫습니다.

원시인도 여전히 첫 번째 예시처럼 코드를 쓰다가 종종 후회하므로, 젊은 원시인을 평가하지 않습니다.

# DRY(Don't Repeat Yourself)

DRY는 자신을 반복하지 말라는 뜻으로, 대부분의 개발자들의 마음을 지배하는 강력한 격언입니다.

원시인은 DRY를 존중하고 좋은 조언이라고 생각하지만, 가장 "큰 뇌"를 가진 아리스토텔레의 말처럼 모든 것에 균형을 추천합니다.

원시인은 Lea Verou의 재미있는 그래프가 반복하지 않으려는 원시인의 열정과 일치한다는 것을 알아챘습니다:

![https://grugbrain.dev/over-time.png](https://grugbrain.dev/over-time.png)

지난 10년간의 프로그래밍을 거치면서 원시인은 코드 반복에 대해 그렇게 걱정하지 않게 되었습니다. 반복되는 코드가 충분히 단순하고 명확한 한, 원시인은 작은 변화가 있는 코드를 반복/복사 붙여넣기하는 것이 많은 콜백/클로저에 인자를 전달하거나 정교한 객체 모델을 만드는 것보다 낫다고 느끼기 시작했습니다: 때로는 너무 작은 이득을 위해 너무 복잡해집니다.

여기서 균형을 잡기가 어렵습니다. 반복되는 코드는 여전히 원시인이 쳐다보며 종종 "음..."이라고 말하게 만들지만, 경험상 반복되는 코드가 때때로 복잡한 DRY 해결책보다 나을 때가 있습니다.

주의하세요! 원시인은 너무 문자 그대로 받아들이는 개발자들에게 말하는데, 이 내용을 너무 심각하게 받아들이지 마세요, 이건 농담입니다.

# 관심사의 분리(SoC)

관심사의 분리(SoC)는 시스템의 서로 다른 측면들을 코드의 구별되는 섹션들로 분리하는 것으로, 많은 개발자의 마음을 지배하는 또 다른 강력한 아이디어입니다.

웹 개발의 대표적인 예시: 스타일(css 파일), 마크업(html 파일), 그리고 로직(javascript 파일)의 분리

여기서 원시인은 SoC를 DRY(Don't Repeat Yourself)보다 훨씬 더 부정적인 입장이에요. 실제로 나는 SoC에 반대되는 '행위의 지역성(LoB, Locality of Behavior)'이라는 대안적 설계 원칙에 대한 깊이 있는 에세이도 썼어요.

원시인은 '그 일을 하는 코드를 그 일을 하는 곳에 두는 것'을 훨씬 더 선호합니다. 이제 원시인이 그 것을 볼 때 원시인은 그 것이 무엇을 하는지 알 수 있습니다. 이건 정말 편리합니다!

관심사를 분리하면 원시인은 종종 버튼이 어떻게 작동하는지 이해하기 위해 여기저기 많은 파일을 봐야 합니다. 매우 혼란스럽고 시간 낭비입니다: 나쁩니다!

# 클로저

원시인은 적절한 작업을 위한 클로저를 좋아하며, 그 작업은 보통 객체 컬렉션에 대한 작업을 추상화하는 것입니다.

원시인은 클로저가 소금, 타입 시스템, 제네릭과 같다고 경고합니다: 적은 양으로도 오래 갈 수 있지만, 너무 많이 사용하면 쉽게 일을 망치고 심장마비를 일으킬 수 있습니다.

자바스크립트 개발자들은 자바스크립트의 매우 특별한 복잡성 악령을 "콜백 지옥"이라고 부릅니다. 자바스크립트 라이브러리들이 너무 많은 클로저를 사용하기 때문입니다. 매우 슬프지만 솔직히 말해서 자바스크립트 개발자들은 자업자득입니다.

# 로깅
원시인은 로깅의 큰 팬이며 많은 로깅을 권장합니다. 특히 클라우드 배포에서요. 일부 원시인이 아닌 사람들은 로깅이 비싸고 중요하지 않다고 말합니다. 원시인도 예전에는 그렇게 생각했지만 이제는 아닙니다.

재미있는 이야기: 원시인은 우상 rob pike가 구글에서 로깅 작업을 하고 있다는 것을 알고 결정했습니다: "rob pike가 로깅 작업을 하고 있다면, 원시인이 거기서 뭘 할 수 있겠어!?" 그래서 추구하지 않았습니다. 알고 보니 로깅이 구글에 *매우* 중요해서 당연히 최고의 프로그래머가 그것을 작업했던 거였습니다, 이런!
그렇게 원시인 뇌를 가지지 말걸 그랬네요, 원시인아, 이제 반짝이는 돌이 훨씬 적어!

뭐, 어쨌든 원시인은 좋은 회사에 가게 되었고, rob pike도 옷 입는 습관이 점점 이상해져서, (난 구글에 못 갔지만, 뭐 Rob Pike도 요즘 이상해졌으니까) 결국 다 잘 됐지만, 요점은 여전합니다: 로깅은 매우 중요합니다!

로깅에 대한 원시인의 팁들:
* 코드 내의 모든 주요 논리 분기(if/for)를 로깅하세요
* "요청"이 클라우드 인프라의 여러 기계에 걸쳐 있다면, 로그를 그룹화할 수 있도록 모든 곳에 요청 ID를 포함하세요
* 가능하다면 로그 레벨을 동적으로 제어할 수 있게 만들어서, 원시인이 이슈를 디버그해야 할 때(많죠!) 켜고 끌 수 있게 하세요
* 가능하다면 사용자별로 로그 레벨을 만들어서, 특정 사용자의 이슈를 디버그할 수 있게 하세요

마지막 두 가지는 프로덕션 시스템의 버그와 싸울 때 매우 자주 특히 유용한 몽둥이입니다.

불행히도 로그 라이브러리들은 종종 매우 복잡합니다(자바야, 왜 이래?) 하지만 원시인의 경험상 로깅 인프라를 "딱 맞게" 만드는 데 시간을 투자하는 것은 나중에 크게 보답받습니다.

로깅은 학교에서 더 많이 가르쳐야 한다고 원시인은 생각합니다.

# 동시성

원시인은 모든 정상적인 개발자처럼 동시성을 두려워합니다.

가능한 한, 원시인은 상태가 없는 웹 요청 핸들러와 작업들이 서로 의존하지 않고 API가 단순한 단순한 원격 작업 워커 큐와 같은 단순한 동시성 모델에 의존하려고 합니다.
낙관적 동시성은 웹 작업에 잘 작동하는 것 같습니다.

가끔 원시인은 스레드 로컬 변수를 사용합니다. 보통 프레임워크 코드를 작성할 때죠.

자바의 ConcurrentHashMap처럼 좋은 동시성 데이터 구조를 가진 언어들도 있지만 여전히 제대로 작동하게 하려면 원시인의 신중한 작업이 필요합니다.

원시인은 erlang을 사용해본 적이 없고, 좋다는 말은 들었지만, 언어가 원시인에게는 이상하게 보입니다. 죄송합니다.

# 최적화

가장 "큰 뇌" 중의 "큰 뇌" 개발자가 한때 말했습니다:

조기 최적화는 모든 악의 근원이다

이것은 대부분의 사람들이 알고 있고 원시인은 겸손하게 가장 "큰 뇌" 중의 "큰 뇌"와 폭력적으로 동의합니다.

원시인은 최적화를 시작하기 전에 항상 구체적이고 실제 성능 프로파일을 가지고 특정 성능 이슈를 보여주는 것을 추천합니다.

실제 이슈가 무엇일지 절대 모릅니다. 원시인도 종종 놀랍니다! 매우 자주요!

CPU에만 집중하는 것을 조심하세요: CPU를 보기 쉽고 학교에서 많은 빅오 표기법 생각을 했지만, 종종 모든 느림의 근원이 아닙니다. 원시인을 포함한 많은 사람들에게 놀라운 일이죠.

네트워크를 치는 것은 수백만 개의 CPU 사이클과 맞먹으며 항상 가능하다면 최소화해야 합니다. "큰 뇌" 마이크로서비스 개발자여, 잘 기억하세요!

경험 없는 "큰 뇌" 개발자는 중첩된 루프를 보고 종종 "O(n^2)? 내가 지켜보는 한 안 돼!"라고 말합니다.
복잡성 악령이 미소 짓습니다.

**Latency numbers every programmer should know - in 2020** - 번역자가 추가
```
  L1 cache reference ......................... 1.0 ns
  Branch mispredict .......................... 3.0 ns
  L2 cache reference ......................... 4.0 ns
  Mutex lock/unlock ........................... 17 ns
  Main memory reference ...................... 100 ns             
  Send 2K bytes over commodity network ........ 44 ns
  Compress 1K bytes with Zippy ............. 2,000 ns  =   2 µs
  SSD random read ......................... 16,000 ns  =  16 µs
  Read 1 MB sequentially from memory ....... 3,000 ns  =   3 µs
  Round trip within same datacenter ...... 500,000 ns  = 500 µs
  Read 1 MB sequentially from SSD* ........ 49,000 ns  =  49 µs
  Disk seek ............................ 2,000,000 ns  =   2 ms
  Read 1 MB sequentially from disk ....... 825,000 ns  = 825 µs
  Send packet CA->Netherlands->CA .... 150,000,000 ns  = 150 ms
```

[Latency numbers every programmer should know 인터렉티브 사이트](https://colin-scott.github.io/personal_website/research/interactive_latency.html)

특별히 주목할 만한 점들:
- 캐시 레이턴시 (L1, L2)는 여전히 매우 빠름 (1-4ns 범위)
- 메모리 접근은 캐시에 비해 약 100배 정도 느림
- SSD는 메모리보다는 느리지만 기계식 하드디스크보다는 훨씬 빠름
- 네트워크 레이턴시는 물리적 거리에 따라 크게 달라짐 (데이터센터 내부 vs 대륙간 통신)
- (메모: 이 비교는 아마 이상적인 조건에서의 단일 작업을 기반으로 한 것임. TCP(Handshake, 응답 확인)나, 많은 데이터를 저장/전송 할 때는 더 느려질 것.)
  - (1GHz의 CPU(core 당)는 1ns에 1번의 연산을 수행함. 2024년 기준 개인 사용자용 하이엔드 CPU가 5~6GHz 정도 나온다.)
  - (실제 성능은 하이퍼스레딩 같은 여러 요소가 있어서서 다를 수 있음.) 

# API

원시인은 좋은 API를 사랑합니다. 좋은 API는 원시인이 너무 많이 생각하게 만들지 않습니다.

불행히도, 많은 API가 매우 나쁘고, 원시인이 꽤 많이 생각하게 만듭니다. 이는 여러 가지 이유로 발생하는데, 여기 두 가지가 있습니다:
* API 제작자들이 API의 사용 측면이 아닌 구현이나 도메인 측면에서 생각합니다
* API 제작자들이 너무 추상적이고 "큰 뇌"스럽게 생각합니다

보통 원시인은 API의 세부사항에 대해 너무 깊이 신경 쓰지 않습니다: 파일을 쓰거나 리스트를 정렬하거나 뭐든지, 그저 `write()`나 `sort()`나 뭐든지 호출하고 싶을 뿐입니다.

하지만 "큰 뇌" API 개발자들은 말합니다:

"그렇게 서두르지 마세요, 원시인! 그 파일이 *쓰기용으로 열려있나요*? 그 정렬을 위한 *Comparator*를 정의했나요?"

원시인은 다시 한번 몽둥이를 잡으려는 손을 제지하고 있습니다.

지금은 그런 것들에 신경 쓰고 싶지 않아요, 그저 정렬하고 파일을 쓰고 싶을 뿐이에요, "큰 뇌" 씨!

원시인은 "큰 뇌" API 설계자들이 *때때로* 이런 것들이 중요하다는 점에서 일리가 있다는 것을 인정하지만, 종종 그렇지 않습니다. "큰 뇌" API 개발자들은 단순한 API로 단순한 경우를 설계하고, 더 복잡한 API로 복잡한 경우를 가능하게 만든다면 더 나을 것입니다.

원시인은 이것을 API "계층화"라고 부릅니다: 다양한 원시인의 요구사항에 맞춰 서로 다른 복잡성 수준의 두세 가지 다른 API를 만드는 것입니다.

또한, 객체 지향이라면, API를 다른 곳이 아닌 그 물건 위에 놓으세요. 자바가 이것을 가장 잘못하고 있습니다!

원시인이 자바에서 리스트를 필터링하고 싶습니다.

"스트림으로 변환하셨나요?"

좋아요, 원시인이 스트림으로 변환했습니다.

"좋습니다, 이제 필터링할 수 있습니다."

좋아요, 하지만 이제 리스트로 반환해야 해요! 스트림이 있어요!

"음, 스트림을 리스트로 수집하셨나요?"

뭐라구요?

"스트림을 리스트로 수집하기 위해 Collector<? super T, A, R>을 정의하세요"

원시인은 이제 조상의 무덤에 맹세하며 방 안의 모든 사람을 몽둥이로 때리겠다고 하지만, 둘을 세고 침착함을 유지합니다.

`filter()`같은 흔한 것을 리스트에 넣고 리스트를 반환하게 만드세요, "큰 뇌" 자바 API 개발자여, 잘 들으세요!
아무도 "스트림"에 대해 신경 쓰지 않고 심지어 전에 들어본 적도 없어요, 이건 네트워킹 API가 아니에요, 모든 자바 원시인들은 리스트를 사용한다구요, "큰 뇌" 씨!

# 파싱
원시인은 모자를 떨어뜨리자마자 프로그래밍 언어를 만드는 것을 사랑하고 [재귀 하강](https://en.wikipedia.org/wiki/Recursive_descent_parser)이 파서를 만드는 가장 재미있고 아름다운 방법이라고 말합니다.
불행히도 많은 "큰 뇌" 학교는 파서 생성기 도구만 가르칩니다. 여기서 원시인의 평소 도구에 대한 사랑이 없습니다: 파서 생성기 도구는 끔찍한 뱀 둥지 같은 코드를 생성합니다: 이해하기 불가능하고, 상향식이고, 뭐라구요? 문법의 재귀적 본질을 원시인으로부터 숨기고 디버그가 불가능합니다. 원시인이 보기에 매우 나쁩니다!

원시인은 이것이 복잡성 악령이 코드베이스와 이해에는 나쁘지만, 많은 학술 논문을 만드는 데는 매우 좋기 때문이라고 생각합니다. 슬프지만 사실이죠.
프로덕션 파서는 학교에서 무시됨에도 불구하고 거의 항상 재귀 하강입니다! 원시인은 파싱이 얼마나 단순한지 알았을 때 격분했습니다! 파싱은 "큰 뇌"만의 마법이 아닙니다: 당신도 할 수 있습니다!

원시인은 "큰 뇌" 개발자 Bob Nystrom이 "큰 뇌" 부족을 구원하고 재귀 하강에 대한 훌륭한 책인 [Crafting Interpreters](https://www.yes24.com/product/goods/123859288)를 쓴 것을 발견하고 매우 기뻤습니다.
책은 [온라인에서 무료](https://craftinginterpreters.com/contents.html)로 볼 수 있지만, 원시인은 일반적인 원칙으로 관심 있는 모든 원시인들이 책을 구매할 것을 강력히 추천합니다. 방문자 패턴(함정!)을 제외하고는 많은 "큰 뇌"의 조언을 제공하고 원시인은 이 책을 *매우* 사랑합니다.

# 방문자 패턴
[나쁨](https://en.wikipedia.org/wiki/Visitor_pattern)

# 프론트엔드 개발

일부 원시인이 아닌 사람들은 웹 개발에 직면했을 때 말합니다:

"알았어, 내 프론트엔드와 백엔드 코드베이스를 분리하고 최신 SPA 라이브러리를 사용해서 HTTP를 통해 GraphQL JSON API 백엔드와 통신할 거야 (하이퍼텍스트를 전송하지 않는데도 말이죠)"

이제 당신은 두 개의 복잡성 악령 소굴을 가지게 되었습니다.

그리고 더 나쁜 것은, 원시인이 알 수 있는 한 프론트엔드 복잡성 악령이 더 강력하고 전체 프론트엔드 산업에 깊은 영적 지배력을 가지고 있다는 것입니다.

백엔드 개발자들은 일을 단순하게 유지하려 노력하고 괜찮게 작동할 수 있지만, 프론트엔드 개발자들은 매우 빠르게 매우 복잡하게 만들고 많은 코드와 복잡성 악령을 도입합니다.

웹사이트가 그저 폼을 데이터베이스에 넣거나 단순한 브로셔 사이트가 필요할 때도 말이죠!
이제 모든 사람이 이렇게 합니다!

원시인은 페이스북과 구글이 그렇게 말했기 때문일 수 있다는 것 말고는 왜 그런지 모르겠지만, 그것은 원시인에게 매우 좋은 이유로 보이지 않습니다.

원시인은 모든 사람이 사용하는 크고 복잡한 프론트엔드 라이브러리를 좋아하지 않습니다.

원시인은 이를 피하기 위해 htmx와 hyperscript를 만들었습니다.

복잡성을 낮게 유지하고, 단순한 HTML을 사용하고, 복잡성 악령의 자연스러운 에테르인 많은 자바스크립트를 피하세요.

아마 당신에게 잘 맞을 수도 있지만, 구인 공고는 없습니다. 죄송합니다.

리액트가 구직과 일부 타입의 애플리케이션에는 더 좋지만, 또한 당신이 좋든 싫든 복잡성 악령의 추종자가 됩니다. 죄송하지만 프론트엔드의 삶이 그렇습니다.

# 유행
원시인은 개발에 많은 유행이 있다는 것을 알아챘습니다. 특히 오늘날 프론트엔드 개발에서요.

백엔드는 이 시점에서 모든 나쁜 아이디어들을 시도해봤기 때문에 더 지루하고 더 낫습니다 (여전히 일부는 다시 시도하지만!).

프론트엔드 개발에서는 여전히 모든 나쁜 아이디어들을 시도하고 있어서 여전히 많은 변화가 있고 알기 어렵습니다.

원시인은 모든 혁명적인 새로운 접근방식을 약간의 의심을 가지고 받아들일 것을 추천합니다: "큰 뇌"들이 이제 오랫동안 컴퓨터에서 작업해왔고, 대부분의 아이디어는 최소한 한 번은 시도되었습니다.

원시인이 새로운 트릭을 배울 수 없거나 좋은 새로운 아이디어가 없다고 말하는 것은 아니지만, 또한 많은 시간이 재활용된 나쁜 아이디어들에 낭비되고, 복잡성 악령의 많은 힘은 새로운 아이디어를 아무렇게나 코드베이스에 넣는 것에서 옵니다.

# 바보처럼 보일 것에 대한 두려움

주목! 시니어 원시인이 공개적으로 "흠, 이건 원시인에게 너무 복잡해"라고 말하는 것은 매우 좋습니다!

많은 개발자들이 바보처럼 보일 것에 대한 두려움(FOLD, Fear Of Looking Dumb)을 가지고 있고, 원시인도 한때는 FOLD를 가졌지만, 원시인은 극복하는 법을 배웠습니다: 시니어 원시인이 "이것은 너무 복잡하고 나를 혼란스럽게 한다"고 말하는 것은 매우 중요합니다.

이것은 주니어 원시인들도 너무 복잡하고 이해하지 못한다는 것을 인정하기 쉽게 만듭니다. 종종 그런 경우가 있죠! FOLD는 개발자에 대한 복잡성 악령 힘의 주요 원천입니다. 특히 젊은 원시인들에게요!

FOLD의 힘을 빼앗는 것, 시니어 원시인의 매우 좋은 일입니다!

참고: 하지만 말할 때 생각하는 표정을 짓고 "큰 뇌"처럼 보이는 것이 중요합니다. "큰 뇌" 또는 더 나쁘고 훨씬 더 흔한, "큰 뇌"라고 *생각하는* 사람이 원시인을 비웃는 발언을 할 준비를 하세요.

강해지세요! FOLD는 안 됩니다!

여기서 몽둥이가 때때로 유용하지만, 더 자주는 유머 감각과 특히 "큰 뇌"의 마지막 실패한 프로젝트가 매우 유용하므로, 수집하고 침착하세요.

# 임포스터 증후군

원시인은 개발에서 많은 임포스터 증후군이 있다는 것을 알아챘습니다.

항상 원시인은 두 가지 상태 중 하나입니다: 원시인이 모든 것을 지배하고 토르처럼 코드 몽둥이를 휘두르거나 또는 원시인이 무엇을 하는지 전혀 모름.

원시인은 대부분의 시간 후자 상태이지만, 꽤 잘 숨깁니다.

이제, 원시인은 많은 작업의 소프트웨어와 적당한 오픈 소스 성공을 만들었지만, 그래도 원시인 자신은 종종 무엇을 하는지 전혀 모른다고 느낍니다! 매우 자주요! 원시인은 여전히 실수로 모든 사람의 코드를 망치고 다른 원시인들을 실망시킬까 봐 두려워합니다. 사기꾼(임포스터)이죠!

아마도 대부분의 원시인이 사기꾼처럼 느끼는 것이 프로그래밍의 본질이고 그것을 받아들이는 것이 최선일 것입니다: 모든 사람이 사기꾼이라면 아무도 사기꾼이 아닙니다.

여기까지 읽은 젊은 원시인은 아마도 좌절과 걱정이 항상 있을 것이지만 프로그래밍 경력에서 잘 할 것입니다. 죄송합니다.

# 읽을거리
원시인이 좋아하는 것들:
* Worse is Better
* Worse is Better is Worse
* Is Worse Really Better?
* A Philosophy of Software Design

# 결론
말하세요: 복잡성은 *매우*, *매우* 나쁩니다.
